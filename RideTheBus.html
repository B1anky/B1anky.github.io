<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Ride the Bus - Chip Counter (Canvas)</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      text-align: center;
      margin: 20px;
      transition: background-color 0.3s, color 0.3s;
    }
    canvas {
      border: 1px solid #ccc;
      background: #f9f9f9;
      cursor: pointer;
    }
    input, button {
      margin: 5px;
      padding: 5px 10px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 14px;
    }
    .mult-button {
      padding: 10px 20px;
      margin: 5px;
      border: 2px solid #ccc;
      cursor: pointer;
      font-size: 16px;
      border-radius: 5px;
      background-color: white;
    }
    .mult-0x {
      color: red;
    }
    .mult-2x {
      color: black;
    }
    .mult-3x {
      color: lightblue;
    }
    .mult-4x {
      color: green;
    }
    .mult-20x {
      color: transparent;
      background-image: linear-gradient(90deg, red, orange, yellow, green, blue, indigo, violet);
      background-clip: text;
      -webkit-background-clip: text;
      font-weight: bold;
      border: 2px solid #ccc;
      border-radius: 5px;
      background-color: white;
    }
    .disabled {
      background-color: #ddd;
      cursor: not-allowed;
    }

    body.dark {
      background-color: #121212;
      color: #f0f0f0;
    }
    body.dark canvas {
      background: #1e1e1e;
      border-color: #444;
    }
    body.dark input, body.dark button {
      background-color: #333;
      color: #f0f0f0;
      border: 1px solid #777;
    }
    body.dark .mult-button {
      border-color: #666;
      background-color: #222;
      color: #f0f0f0;
    }
    body.dark .mult-0x { color: red; }
    body.dark .mult-2x { color: #f0f0f0; }
    body.dark .mult-3x { color: lightblue; }
    body.dark .mult-4x { color: lightgreen; }
    body.dark .mult-20x {
      color: transparent;
      background-image: linear-gradient(90deg, red, orange, yellow, green, blue, indigo, violet);
      background-clip: text;
      -webkit-background-clip: text;
      border-color: #666;
      background-color: #222;
    }

    .game-container {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      margin: 20px;
    }
    
    .top-controls {
      display: flex;
      margin-bottom: 20px;
      flex-wrap: wrap;
      width: 100%;
      align-items: center;
      gap: 20px;
    }
    
    .top-controls-player-segment {
      flex: 1;
      min-width: 300px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .top-controls-card-segment {
      flex: 1;
      min-width: 300px;
    }
    
    .top-controls .draw-button {
      margin: 0;
    }
    
    .game-area {
      display: flex;
      gap: 20px;
      width: 100%;
    }
    
    .player-area {
      flex: 1;
      min-width: 300px;
      margin: 0;
      padding: 10px;
      border: 1px solid #ccc;
      border-radius: 5px;
      text-align: left;
    }
    
    .card-area {
      flex: 1;
      min-width: 300px;
      padding: 10px;
      border: 1px solid #ccc;
      border-radius: 5px;
    }
    
    .deck {
      width: 100px;
      height: 140px;
      border: 2px solid #333;
      border-radius: 8px;
      margin: 10px auto;
      cursor: pointer;
      background: #fff;
      position: relative;
    }
    
    .deck::after {
      content: var(--deck-content);
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 24px;
    }
    
    .drawn-cards {
      display: flex;
      gap: 10px;
      margin-top: 20px;
      min-height: 140px;
    }
    
    .card {
      width: 100px;
      height: 140px;
      border: 1px solid #333;
      border-radius: 8px;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      background: #fff;
    }
    
    .player-choice {
      display: flex;
      gap: 10px;
      margin: 5px 0;
    }
    
    .choice-button {
      padding: 5px 10px;
      border: 1px solid #ccc;
      border-radius: 4px;
      cursor: pointer;
    }
    
    .choice-button.selected {
      background-color: #4CAF50;
      color: white;
    }
    
    .round-info {
      margin: 10px 0;
      padding: 10px;
      background: #f0f0f0;
      border-radius: 4px;
    }
    
    body.dark .card-area {
      border-color: #666;
    }
    
    body.dark .deck,
    body.dark .card {
      border-color: #666;
      background: #333;
      color: #fff;
    }
    
    body.dark .round-info {
      background: #333;
    }

    .round-multiplier {
      font-size: 1.2em;
      font-weight: bold;
      margin: 10px 0;
      padding: 5px;
      border-radius: 4px;
      background: #f0f0f0;
    }
    
    .player-bet-controls {
      display: flex;
      align-items: center;
      gap: 10px;
      margin: 5px 0;
    }
    
    .bet-button {
      padding: 5px 10px;
      border: 1px solid #ccc;
      border-radius: 4px;
      cursor: pointer;
      background: white;
    }
    
    .bet-button.selected {
      background: #4CAF50;
      color: white;
    }
    
    .cash-out-button {
      padding: 5px 10px;
      background: #ffd700;
      border: 1px solid #cca300;
      border-radius: 4px;
      cursor: pointer;
      font-weight: bold;
    }
    
    body.dark .round-multiplier {
      background: #333;
    }
    
    body.dark .bet-button {
      background: #333;
      color: #fff;
      border-color: #666;
    }
    
    body.dark .bet-button.selected {
      background: #2e7d32;
    }
    
    body.dark .cash-out-button {
      background: #b8860b;
      border-color: #8b6914;
      color: #fff;
    }

    .draw-button {
      display: block;
      margin: 20px auto;
      padding: 10px 20px;
      font-size: 18px;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      transition: background-color 0.3s;
    }

    .draw-button:hover {
      background-color: #45a049;
    }

    .draw-button:disabled {
      background-color: #cccccc;
      cursor: not-allowed;
    }

    .player-controls {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-bottom: 10px;
    }

    .player-name, .player-chips, .player-bet, .choice-buttons {
      height: 40px;
      display: flex;
      align-items: center;
      box-sizing: border-box;
    }

    .player-name {
      /* flex-basis: 150px; */ /* JS will set this */
      min-width: 100px; /* Fallback min-width */
      flex-shrink: 0; 
      overflow: hidden;
    }

    .player-chips {
      /* flex-basis: 120px; */ /* JS will set this */
      min-width: 80px; /* Fallback min-width */
      flex-shrink: 0;
      text-align: right; 
      justify-content: flex-end;
    }

    .player-bet {
      /* flex-basis: 220px; */ /* JS will set this */
      min-width: 150px; /* Fallback min-width */
      flex-shrink: 0;
    }

    .choice-buttons {
      /* flex-basis: 200px; */ /* JS will set this */
      min-width: 150px; /* Fallback min-width */
      flex-shrink: 0;
      flex-wrap: wrap; 
    }

    .choice-buttons button {
      padding: 8px 10px;
      border: 1px solid #ccc;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      min-width: 60px;
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100%;
      box-sizing: border-box;
    }

    .choice-buttons button:hover {
      background-color: #f0f0f0;
    }

    .selected-player {
      color: #4CAF50;
      font-weight: bold;
      cursor: pointer;
    }

    .cash-out-button:hover {
      background-color: #ffed4a;
    }

    .wall-of-shame {
      margin-top: 20px;
      padding: 10px;
      border: 1px solid #ccc;
      border-radius: 5px;
      background-color: #f9f9f9;
    }

    .wall-of-shame h3 {
      margin-top: 0;
      color: #c00;
    }

    .wall-of-shame p {
      margin: 5px 0;
    }

    body.dark .wall-of-shame {
      background-color: #1e1e1e;
      border-color: #444;
    }

    body.dark .wall-of-shame h3 {
      color: #ff4d4d;
    }

    .player-bet input[type="number"] {
      flex-grow: 1;
      height: 100%;
      box-sizing: border-box;
      padding: 5px;
      border: 1px solid #ccc;
      border-radius: 4px;
    }

    .player-bet button {
      height: 100%;
      box-sizing: border-box;
      padding: 8px 10px;
      border: 1px solid #ccc;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    body.dark #debugArea {
      background-color: #1e1e1e; /* Match other dark theme sections */
      border-color: #444;    /* Match other dark theme borders */
      color: #f0f0f0;        /* Default dark theme text color */
    }
  </style>
</head>
<body>
  <h1>Ride the Bus - Card Game</h1>

  <div class="game-container">
    <div class="top-controls">
      <div class="top-controls-player-segment">
        <div style="display: flex; gap: 10px;">
          <button onclick="resetPlayers()">Reset All Players</button>
          <button onclick="toggleTheme()">Toggle Dark Mode</button>
        </div>
        <div style="display: flex; gap: 10px;">
          <button id="newGameButton" class="draw-button" onclick="startNewGame()">New Game</button>
          <button id="drawCardButton" class="draw-button" onclick="drawCard()" style="display:none">Draw Card</button>
        </div>
      </div>
      <div class="top-controls-card-segment">
        <!-- Empty, serves to correctly proportion the player segment -->
      </div>
    </div>

    <div class="game-area">
      <div id="playerArea" class="player-area">
        <!-- Player controls will be dynamically added here -->
      </div>
      
      <div class="card-area">
        <div class="round-info" id="roundInfo">
          Round 1: Guess if the card is Red or Black
        </div>
        
        <div class="round-multiplier" id="roundMultiplier">
          Current Round: 1 (2x multiplier if you cash out)
        </div>
        
        <div class="deck" id="deck"></div>
        
        <div class="drawn-cards" id="drawnCards"></div>
      </div>
    </div>

    <div id="wallOfShameArea" class="wall-of-shame" style="display: none;">
      <h3>Wall of Shame</h3>
      <div id="wallOfShameContent">
        <!-- Debt information will be dynamically added here -->
      </div>
    </div>

    <div id="debugArea" style="display: none; margin-top: 15px; padding: 10px;">
      <h4>Debug Info</h4>
      <div>
        <label for="toggleDebugNextCard">Show Next Card: </label>
        <input type="checkbox" id="toggleDebugNextCard" onchange="updateDebugNextCardDisplay()">
      </div>
      <div id="debugNextCard" style="margin-top: 5px; font-weight: bold; min-height: 20px;">
        Next Card: (Hidden)
      </div>
    </div>

  </div>

<script>
// Game State Constants
const PHASE_BETTING = 'betting';
const PHASE_PLAYING = 'playing';
const PHASE_GAME_OVER = 'gameOver';

const CHOICE_RED = 'red';
const CHOICE_BLACK = 'black';
const CHOICE_HIGHER = 'higher';
const CHOICE_LOWER = 'lower';
const CHOICE_INSIDE = 'inside';
const CHOICE_OUTSIDE = 'outside';

const SUIT_SPADES = '♠';
const SUIT_HEARTS = '♥';
const SUIT_DIAMONDS = '♦';
const SUIT_CLUBS = '♣';

const CARD_VALUES_WITH_ACE_HIGH = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];

let players = {};
let selectedPlayer = null;

// Add these initializations
let currentRound = 1;
let gameInProgress = false;
let activePlayers = new Set();
let deck = [];
let drawnCards = [];
const roundMultipliers = {
    1: 2,  // 2x for R1 cash out (not really a thing, but for consistency if game ended after R0)
    2: 3,  // 3x for R2 cash out (based on R1 bet)
    3: 4,  // 4x for R3 cash out (based on R2 bet)
    4: 20, // 20x for R4 WIN or R5 cash out (based on R3 bet that won R4)
    5: 50  // 50x for R5 WIN (exact card guess)
};

// Add at the top with other state variables:
let gamePhase = PHASE_BETTING; // Initial phase

// Initialize the deck
function initializeDeck() {
    const suits = ['♠', '♥', '♦', '♣'];
    const values = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
    console.log("initializeDeck");
    deck = [];
    for (let suit of suits) {
        for (let value of values) {
            deck.push({ suit, value });
        }
    }
    // Shuffle the deck
    for (let i = deck.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [deck[i], deck[j]] = [deck[j], deck[i]];
    }
    updateDeckDisplay();
    updateDebugNextCardDisplay();
}

// Call initializeDeck when starting a new game
function startNewRound() {
    currentRound = 1;
    drawnCards = [];
    activePlayers = new Set(Object.keys(players).filter(playerName => players[playerName].chips > 0));
    
    // Reset eliminated status and bet commitment for all players
    Object.keys(players).forEach(playerName => {
        players[playerName].eliminated = false;
        players[playerName].currentChoice = undefined;
        players[playerName].lastBet = 0;
    });
    
    updateRoundInfo();
    updatePlayerArea();
    updateGameButtons();
    updateDeckDisplay();
    updateDebugNextCardDisplay();
}

// Theme handling
function toggleTheme() {
  const isDark = document.body.classList.toggle('dark');
  localStorage.setItem('theme', isDark ? 'dark' : 'light');
  updatePlayerArea();
  updateDebugNextCardDisplay();

  // Reapply the highlight to the selected choice buttons
  Object.entries(players).forEach(([name, player]) => {
    if (player.currentChoice) {
      const playerDiv = document.querySelector(`.player-controls input[value="${name}"]`).parentElement;
      const choiceButtons = playerDiv.querySelectorAll('.choice-button');
      choiceButtons.forEach(button => {
        if (button.textContent.toLowerCase() === player.currentChoice) {
          button.classList.add('selected');
        } else {
          button.classList.remove('selected');
        }
      });
    }
  });
}

(function loadTheme() {
  const theme = localStorage.getItem('theme');
  if (theme === 'dark') {
    document.body.classList.add('dark');
  }
})();

// Load players from localStorage
window.onload = () => {
  const saved = localStorage.getItem('chipCounterPlayers');
  if (saved) {
    players = JSON.parse(saved);
    // Initialize active players set with players who have bets
    activePlayers = new Set(Object.keys(players).filter(playerName => players[playerName].chips > 0));
    // Initialize game state if needed
    if (shouldGameBeInProgress()) {
        gameInProgress = true;
        if (!deck || deck.length === 0) {
            initializeDeck();
        }
    }
        
    updatePlayerArea();
  }

  updateRoundInfo();
  updateGameButtons();
  updateDeckDisplay();
  updateDebugNextCardDisplay();
};

function savePlayers() {
  localStorage.setItem('chipCounterPlayers', JSON.stringify(players));
  updateDeckDisplay();
  updateDebugNextCardDisplay();
}

function addPlayer() {
  const name = document.getElementById('playerName').value.trim();
  const chips = parseInt(document.getElementById('playerChips').value);

  if (name && !isNaN(chips) && chips >= 0) {
    if (players[name]) {
      players[name].chips += chips;
      players[name].debt = (players[name].debt || 0) + chips;
    } else {
      players[name] = { chips, lastBet: 0, debt: 0, currentChoice: undefined, historicalBet: 0 };
    }
    updatePlayerArea();
    savePlayers();
  } else {
    alert('Enter a valid name and chip amount.');
  }
}

function payDebt(playerName) {
  const targetPlayerName = playerName || selectedPlayer;
  if (!targetPlayerName) {
    alert('Select a player or use the specific pay debt button.');
    return;
  }
  const player = players[targetPlayerName];
  if (player && player.debt > 0 && player.chips > 0) {
    const payment = Math.min(player.chips, player.debt);
    player.chips -= payment;
    player.debt -= payment;
    console.log(`${targetPlayerName} paid ${payment} towards debt. Remaining debt: ${player.debt}, Chips: ${player.chips}`);
    updatePlayerArea(); // This will update their display and the Wall of Shame
    savePlayers();
  } else if (player && player.debt <= 0) {
    alert(`${targetPlayerName} has no debt to pay.`);
  } else if (player && player.chips <= 0) {
    alert(`${targetPlayerName} has no chips to pay with.`);
  } else {
    alert(`Player ${targetPlayerName} not found.`);
  }
}

function resetPlayers() {
  if (confirm('Are you sure you want to reset all player data?')) {
    // Reset player data
    players = {};
    selectedPlayer = null;

    // Reset game state
    gameInProgress = false;
    currentRound = 1;
    drawnCards = [];
    activePlayers.clear(); // Clear the active players set

    // Clear the drawn cards display
    updateDrawnCardsDisplay();

    // Reset the deck
    initializeDeck();

    // Update UI
    updateRoundInfo();
    updatePlayerArea();

    // Reset and disable the draw button
    const drawButton = document.getElementById('drawCardButton');
    if (drawButton) {
        drawButton.textContent = 'Draw Card';
        drawButton.disabled = true; // Disable until a new game starts
    }

    // Save the reset state
    savePlayers();
  }
}

function updatePlayerArea() {
    const playerArea = document.getElementById('playerArea');
    playerArea.innerHTML = '';

    Object.entries(players).forEach(([name, player]) => {
        const playerDiv = createPlayerControlsDiv(name, player);
        playerArea.appendChild(playerDiv);
    });
    updateGameButtons();
    updateWallOfShame(); 
    createPlayerManagementRow();
    calculateAndApplyColumnWidths(); 
}

function createPlayerControlsDiv(name, player) {
    const playerDiv = document.createElement('div');
    playerDiv.className = 'player-controls';

    appendPlayerNameDiv(playerDiv, name);
    appendPlayerChipsDiv(playerDiv, player);
    appendBetControls(playerDiv, name, player);
    appendChoiceAndCashOutButtons(playerDiv, name, player);

    return playerDiv;
}

function appendPlayerNameDiv(parentDiv, name) {
    const nameDiv = document.createElement('div');
    nameDiv.className = 'player-name';
    nameDiv.textContent = name;
    parentDiv.appendChild(nameDiv);
}

function appendPlayerChipsDiv(parentDiv, player) {
    const chipsDiv = document.createElement('div');
    chipsDiv.className = 'player-chips';
    chipsDiv.textContent = `Chips: ${player.chips}`;
    parentDiv.appendChild(chipsDiv);
}

function appendBetControls(parentDiv, name, player) {
    const betControlsContainer = document.createElement('div');
    betControlsContainer.className = 'player-bet';

    const betInputId = `betInput_${name}`;
    const betInput = document.createElement('input');
    betInput.type = 'number';
    betInput.id = betInputId;
    betInput.value = player.lastBet;
    betInput.min = 0;
    betInput.max = player.chips > 0 ? player.chips : 0;

    betInput.onchange = () => {
        let newBet = parseInt(betInput.value) || 0;
        if (newBet < 0) newBet = 0;
        if (newBet > player.chips) {
            newBet = player.chips;
            betInput.value = newBet;
            alert("Bet cannot exceed current chips. Bet adjusted.");
        }
        player.lastBet = newBet;
        activePlayers = getActivePlayers();
        updatePlayerArea(); 
        updateGameButtons();
    };
    betInput.readOnly = gamePhase === PHASE_PLAYING || player.chips <= 0;
    if (player.chips <= 0 && gamePhase !== PHASE_PLAYING) {
        player.lastBet = 0;
        betInput.value = 0;
    }
    betControlsContainer.appendChild(betInput);

    if ((gamePhase === PHASE_BETTING || gamePhase === PHASE_GAME_OVER) && player.historicalBet > 0 && player.chips >= player.historicalBet) {
        const useLastBetButton = document.createElement('button');
        useLastBetButton.textContent = `Use Last (${player.historicalBet})`;
        useLastBetButton.className = 'use-last-bet-button';
        useLastBetButton.style.marginLeft = '5px';
        useLastBetButton.onclick = () => {
            const betInputElement = document.getElementById(betInputId);
            if (betInputElement) {
                if (player.chips >= player.historicalBet) {
                    betInputElement.value = player.historicalBet;
                    betInputElement.dispatchEvent(new Event('change', { bubbles: true }));
                } else {
                    alert("Not enough chips to use last bet amount.");
                }
            }
        };
        betControlsContainer.appendChild(useLastBetButton);
    }

    if (player.debt > 0 && player.chips > 0) {
        const payDebtButton = document.createElement('button');
        payDebtButton.textContent = 'Pay Debt';
        payDebtButton.className = 'choice-button'; 
        payDebtButton.style.marginLeft = '10px'; 
        payDebtButton.onclick = () => payDebt(name);
        betControlsContainer.appendChild(payDebtButton);
    }
    parentDiv.appendChild(betControlsContainer);
}

function appendChoiceAndCashOutButtons(parentDiv, name, player) {
    if (!activePlayers.has(name) || player.lastBet <= 0) return; // Don't show if no bet or not active

    const buttonsContainer = document.createElement('div');
    buttonsContainer.className = 'choice-buttons';
    let choices = [];
    let createActiveChoiceButtons = false;

    if (gamePhase === PHASE_BETTING) {
        choices = [CHOICE_RED, CHOICE_BLACK];
        createActiveChoiceButtons = true;
    } else if (gamePhase === PHASE_PLAYING) {
        createActiveChoiceButtons = true;
        switch (currentRound) {
            case 1: choices = [CHOICE_RED, CHOICE_BLACK]; break;
            case 2: choices = [CHOICE_HIGHER, CHOICE_LOWER]; break;
            case 3: choices = [CHOICE_INSIDE, CHOICE_OUTSIDE]; break;
            case 4: choices = [SUIT_SPADES, SUIT_HEARTS, SUIT_DIAMONDS, SUIT_CLUBS]; break;
            case 5: choices = []; /* Special handling for R5 below */ break;
        }

        // Cash Out button first (if applicable)
        if (currentRound > 1 && currentRound <= 5) { // Cash out available up to start of R5
            const cashOutButton = document.createElement('button');
            cashOutButton.className = 'cash-out-button';
            const multiplierRoundForCashOut = (currentRound === 5) ? 4 : currentRound - 1;
            const cashOutMultiplier = roundMultipliers[multiplierRoundForCashOut];
            if (cashOutMultiplier !== undefined && player.lastBet > 0) {
                cashOutButton.textContent = `Cash Out (${cashOutMultiplier}x = ${player.lastBet * cashOutMultiplier} chips)`;
            } else {
                cashOutButton.textContent = 'Cash Out (N/A)';
            }
            cashOutButton.onclick = () => handleCashOut(name);
            buttonsContainer.appendChild(cashOutButton);
        }

        // Round 5: Special Input - Dropdown for card value
        if (currentRound === 5) {
            const valueSelect = document.createElement('select');
            valueSelect.id = `r5_value_select_${name}`;
            valueSelect.className = 'choice-button'; // For styling consistency

            // Add a placeholder option
            const placeholderOption = document.createElement('option');
            placeholderOption.value = ""; // Empty value for placeholder
            placeholderOption.textContent = "Guess Value...";
            placeholderOption.selected = true;
            placeholderOption.disabled = true;
            valueSelect.appendChild(placeholderOption);

            CARD_VALUES_WITH_ACE_HIGH.forEach(val => {
                const option = document.createElement('option');
                option.value = val;
                option.textContent = val;
                valueSelect.appendChild(option);
            });
            
            // Set current choice if exists, otherwise placeholder remains selected
            if (player.currentChoice) {
                valueSelect.value = player.currentChoice;
            }

            valueSelect.onchange = function() {
                const selectedValue = this.value;
                if (selectedValue) { // Ensure a real value is selected, not the placeholder
                    makeChoice(name, selectedValue);
                }
            };
            buttonsContainer.appendChild(valueSelect);
        }
    }

    // Standard choice buttons for rounds 1-4
    if (choices.length > 0 && currentRound < 5) { // Only for rounds 1-4
        choices.forEach(choiceText => {
            const button = document.createElement('button');
            button.className = 'choice-button';
            button.textContent = choiceText.charAt(0).toUpperCase() + choiceText.slice(1);
            if (createActiveChoiceButtons) {
                button.onclick = () => makeChoice(name, choiceText);
                button.disabled = false;
            } else {
                button.disabled = true;
            }
            if (player.currentChoice && choiceText.toLowerCase() === player.currentChoice.toLowerCase()) {
                button.classList.add('selected');
            }
            buttonsContainer.appendChild(button);
        });
    }

    if (buttonsContainer.hasChildNodes()) {
        parentDiv.appendChild(buttonsContainer);
    }
}

function calculateAndApplyColumnWidths() {
    const columnClasses = ['.player-name', '.player-chips', '.player-bet', '.choice-buttons'];
    // Ensure we only select elements within player rows, not the management row if it uses similar classes by mistake
    const playerRows = document.querySelectorAll('#playerArea .player-controls:not(.management-row)');

    if (playerRows.length === 0) return; // No player rows to process

    columnClasses.forEach(selector => {
        let maxWidth = 0;
        const elementsToMeasure = [];

        playerRows.forEach(row => {
            const el = row.querySelector(selector);
            if (el) {
                // Temporarily reset flex-basis to auto to measure natural content width
                // This is important if this function is called multiple times (e.g., on resize)
                el.style.flexBasis = 'auto'; 
                elementsToMeasure.push(el);
            }
        });
        
        // Calculate max width after resetting basis (or rely on scrollWidth if basis was auto)
        elementsToMeasure.forEach(el => {
            // Force a reflow to ensure scrollWidth is accurate after style changes if any
            // void el.offsetWidth; // Reading offsetWidth can trigger reflow
            // Using getComputedStyle and width/padding/border or just scrollWidth
            // For simplicity with box-sizing: border-box, scrollWidth should be okay.
            if (el.scrollWidth > maxWidth) {
                maxWidth = el.scrollWidth;
            }
        });

        // Apply the found max width to all elements in that column
        // Add a little padding/buffer to the max width for safety, e.g., 5-10px
        const finalWidth = maxWidth + 5; // Add a small buffer
        
        elementsToMeasure.forEach(el => {
            el.style.flexBasis = `${finalWidth}px`;
        });
        // console.log(`Applied width ${finalWidth}px to elements with selector ${selector}`);
    });
}

function createPlayerManagementRow() {
    const playerArea = document.getElementById('playerArea');
    const controlRow = document.createElement('div');
    // controlRow.className = 'player-controls management-row'; // Remove to avoid 4-column grid
    controlRow.className = 'management-row'; // Just for potential specific styling, not grid
    controlRow.style.display = 'flex';
    controlRow.style.gap = '10px';
    controlRow.style.alignItems = 'center';
    controlRow.style.marginTop = '20px'; // A bit more spacing for this distinct row
    controlRow.style.padding = '10px';
    controlRow.style.border = '1px solid #444'; // Visually group them
    controlRow.style.borderRadius = '5px';

    // Name Input Cell
    const nameCell = document.createElement('div');
    nameCell.style.flexBasis = '40%'; // Approx percentage
    const nameInput = document.createElement('input');
    nameInput.type = 'text';
    nameInput.id = 'newPlayerNameInput';
    nameInput.setAttribute('list', 'playerDatalist');
    nameInput.placeholder = 'New Player Name';
    nameInput.style.width = '100%'; 
    nameInput.style.height = '40px'; 
    nameInput.style.boxSizing = 'border-box';
    nameCell.appendChild(nameInput);
    const dataList = document.createElement('datalist');
    dataList.id = 'playerDatalist';
    Object.keys(players).forEach(playerName => {
        const option = document.createElement('option');
        option.value = playerName;
        dataList.appendChild(option);
    });
    nameCell.appendChild(dataList); 
    controlRow.appendChild(nameCell);

    // Chips Input Cell
    const chipsCell = document.createElement('div');
    chipsCell.style.flexBasis = '25%'; // Approx percentage
    const chipsInput = document.createElement('input');
    chipsInput.type = 'number';
    chipsInput.id = 'newPlayerChipsInput';
    chipsInput.placeholder = 'Starting Chips';
    chipsInput.min = 0;
    chipsInput.style.width = '100%'; 
    chipsInput.style.height = '40px';
    chipsInput.style.boxSizing = 'border-box';
    chipsCell.appendChild(chipsInput);
    controlRow.appendChild(chipsCell);

    // Action Button Cell
    const buttonCell = document.createElement('div');
    buttonCell.style.flexGrow = '1'; // Let it take remaining space or a fixed basis
    buttonCell.style.flexBasis = '30%'; // Approx percentage
    const actionButton = document.createElement('button');
    actionButton.id = 'newAddPlayerButton';
    actionButton.textContent = 'Add Player';
    actionButton.style.width = '100%'; 
    actionButton.style.height = '40px'; 
    actionButton.style.boxSizing = 'border-box';
    buttonCell.appendChild(actionButton);
    controlRow.appendChild(buttonCell);

    // Event listener for name input 
    nameInput.addEventListener('input', () => {
        const enteredName = nameInput.value.trim();
        if (players[enteredName]) {
            chipsInput.placeholder = 'Loaning Chips';
            actionButton.textContent = 'Apply for Financial Assistance';
        } else {
            chipsInput.placeholder = 'Starting Chips';
            actionButton.textContent = 'Add Player';
        }
    });

    // Action button click handler
    actionButton.onclick = handleAddPlayerOrLoan;

    // Enable/Disable controls based on game phase
    const UIElementsToToggle = [nameInput, chipsInput, actionButton];
    if (gamePhase === PHASE_PLAYING) {
        UIElementsToToggle.forEach(el => el.disabled = true);
    } else {
        UIElementsToToggle.forEach(el => el.disabled = false);
    }

    playerArea.appendChild(controlRow);
}

function handleAddPlayerOrLoan() {
    const nameInput = document.getElementById('newPlayerNameInput');
    const chipsInput = document.getElementById('newPlayerChipsInput');
    const name = nameInput.value.trim();
    const chips = parseInt(chipsInput.value);

    if (!name || isNaN(chips) || chips < 0) {
        alert('Please enter a valid name and a non-negative chip amount.');
        return;
    }

    if (players[name]) {
        // Existing player: Apply for loan
        players[name].chips += chips;
        players[name].debt = (players[name].debt || 0) + chips;
        console.log(`Loan of ${chips} chips given to ${name}. New balance: ${players[name].chips}, New Debt: ${players[name].debt}`);
    } else {
        // New player
        players[name] = { chips, lastBet: 0, debt: 0, currentChoice: undefined, historicalBet: 0 };
        console.log(`New player ${name} added with ${chips} chips.`);
    }

    updatePlayerArea(); // This will re-render everything including the management row and player list
    updateWallOfShame();
    savePlayers();

    // Clear inputs after action
    nameInput.value = '';
    chipsInput.value = '';
    // Trigger input event to reset placeholders and button text
    nameInput.dispatchEvent(new Event('input')); 
}

function makeChoice(playerName, choice) {
    const player = players[playerName];
    if (player.lastBet <= 0) {
        console.log(`Cannot make choice for ${playerName} - no bet placed`);
        return;
    }
    
    player.currentChoice = choice;

    // updatePlayerArea will handle visual updates including selection and disabling buttons
    updatePlayerArea(); 
    updateGameButtons(); // Update main game button states (e.g., enable Draw Card if all choices made)

    console.log('Game State after choice:', {
        currentRound,
        gameInProgress,
        activePlayers: Array.from(activePlayers),
        drawnCards,
        players: Object.fromEntries(
            Object.entries(players).map(([name, p]) => [
                name,
                {
                    chips: p.chips,
                    lastBet: p.lastBet,
                    currentChoice: p.currentChoice,
                }
            ])
        )
    });
}

function drawCard() {
    updateDeckDisplay();
    console.log('[DrawCard] Called. State before draw:', {
        gamePhase,
        gameInProgress,
        activePlayers: Array.from(activePlayers),
        players: Object.fromEntries(Object.entries(players).map(([name, p]) => ({
            [name]: {
                lastBet: p.lastBet,
                currentChoice: p.currentChoice,
                chips: p.chips,
                historicalBet: p.historicalBet // Log historicalBet
            }
        }))),
        deckLength: deck.length,
        drawnCards: drawnCards.map(card => card.value + card.suit)
    });
    if (gamePhase === PHASE_BETTING) {
        if (activePlayers.size === 0 || !allActivePlayersMadeChoices()) {
            console.log('[DrawCard] Early return: Not all active players have placed bets and made choices.');
            alert('All active players must place bets and make their choices before starting.');
            return;
        }

        activePlayers.forEach(playerName => {
            const player = players[playerName];
            // Store the bet they are starting the game with as historicalBet
            if (player.lastBet > 0) {
                player.historicalBet = player.lastBet;
                console.log(`[DrawCard] Stored historicalBet for ${playerName}: ${player.historicalBet}`);
            }
            // Deduct current bet from chips
            if (player.lastBet > 0) { 
                player.chips -= player.lastBet;
                console.log(`[DrawCard] Deducted ${player.lastBet} chips from ${playerName}. New chip count: ${player.chips}`);
            }
        });

        gamePhase = PHASE_PLAYING;
        console.log('[DrawCard] Transitioned to playing phase');
        gameInProgress = true;
        currentRound = 1;
        drawnCards = [];
        updateRoundInfo();
        updatePlayerArea(); 
        updateDeckDisplay();
        updateGameButtons();
        updateDebugNextCardDisplay();
        console.log('[DrawCard] Game started.');
    }
    if (!allActivePlayersMadeChoices() || deck.length === 0) {
        console.log('[DrawCard] Early return: Not all choices made or deck is empty.', {
            allChoicesMade: allActivePlayersMadeChoices(),
            deckLength: deck.length
        });
        return;
    }
    const card = deck.pop();
    drawnCards.push(card);
    console.log('[DrawCard] Drew card:', card, 'Drawn cards:', drawnCards.map(c => c.value + c.suit));
    updateDrawnCardsDisplay();
    updateDeckDisplay();
    processRoundResults(card);
    updatePlayerArea();
    updateGameButtons();
    updateDebugNextCardDisplay();
    console.log('[DrawCard] State after draw:', {
        gamePhase,
        gameInProgress,
        activePlayers: Array.from(activePlayers),
        players: Object.fromEntries(Object.entries(players).map(([name, p]) => ({
            [name]: {
                lastBet: p.lastBet,
                currentChoice: p.currentChoice,
                chips: p.chips,
                historicalBet: p.historicalBet // Log historicalBet
            }
        }))),
        deckLength: deck.length,
        drawnCards: drawnCards.map(card => card.value + card.suit)
    });
}

function updateDrawnCardsDisplay() {
  const container = document.getElementById('drawnCards');
  container.innerHTML = '';
  
  drawnCards.forEach(card => {
    const cardElement = document.createElement('div');
    cardElement.className = 'card';
    cardElement.style.color = ['♥', '♦'].includes(card.suit) ? 'red' : 'black';
    cardElement.textContent = `${card.value}${card.suit}`;
    container.appendChild(cardElement);
  });
}

function processRoundResults(card) {
    const isRed = [SUIT_HEARTS, SUIT_DIAMONDS].includes(card.suit);
    const playersToProcess = new Set(activePlayers);

    playersToProcess.forEach(playerName => {
        const player = players[playerName];
        const choice = player.currentChoice;
        let playerLost = false;

        switch (currentRound) {
            case 1: playerLost = evaluateRound1Win(choice, isRed); break;
            case 2: playerLost = evaluateRound2Win(choice, card, drawnCards); break;
            case 3: playerLost = evaluateRound3Win(choice, card, drawnCards); break;
            case 4: playerLost = evaluateRound4Win(choice, card); break;
            case 5: playerLost = evaluateRound5Win(choice, card); break;
        }

        console.log(`Player ${playerName} result:`, { choice, cardSuit: card.suit, cardValue: card.value, playerLost, currentRound });

        if (playerLost) {
            activePlayers.delete(playerName);
            player.lastBet = 0;
            player.currentChoice = undefined;
            console.log(`Player ${playerName} lost round ${currentRound} and was removed from activePlayers.`);
        } else {
            player.currentChoice = undefined; 
            if (currentRound === 4 && !playerLost) {
                console.log(`Player ${playerName} won Round 4. Bet carries to Round 5 or cash out option.`);
            } else if (currentRound === 5 && !playerLost) {
                const multiplier = roundMultipliers[currentRound];
                player.chips += player.lastBet * multiplier;
                console.log(`Player ${playerName} won Round 5! Awarded ${player.lastBet * multiplier} chips.`);
                player.lastBet = 0;
                activePlayers.delete(playerName);
                console.log(`Player ${playerName} won Round 5 and was removed from activePlayers.`);
            } else if (playerLost) {
                activePlayers.delete(playerName);
                player.lastBet = 0;
                console.log(`Player ${playerName} lost round ${currentRound} and was removed from activePlayers.`);
            }
        }
    });

    if (activePlayers.size === 0) {
        console.log('[ProcessResults] All players processed or eliminated. Ending game.');
        endGame();
        return;
    }

    const roundBeforeIncrement = currentRound;
    console.log(`[ProcessResults] CHECKPOINT: Round before increment decision: ${roundBeforeIncrement}. Active players: ${activePlayers.size}, names: ${Array.from(activePlayers).join(', ')}`);

    if (roundBeforeIncrement < 5) {
        currentRound++;
        console.log(`[ProcessResults] Incremented to round ${currentRound}. Updating info.`);
        updateRoundInfo(); 
    } else { 
        console.log(`[ProcessResults] roundBeforeIncrement (${roundBeforeIncrement}) was not < 5. Ending game.`);
        endGame();
    }
    
    console.log(`[ProcessResults] About to call updatePlayerArea. Current round is NOW: ${currentRound}. Game phase: ${gamePhase}. Active players: ${activePlayers.size}`);
    updatePlayerArea(); 
}

function evaluateRound1Win(choice, isRed) {
    return (choice === CHOICE_RED && !isRed) || (choice === CHOICE_BLACK && isRed);
}

function evaluateRound2Win(choice, currentCard, allDrawnCards) {
    if (allDrawnCards.length < 2) return true; // Should not happen if logic is correct, treat as loss
    const currentValue = getCardValue(currentCard.value);
    const prevValue = getCardValue(allDrawnCards[allDrawnCards.length - 2].value);
    if ((choice === CHOICE_HIGHER && currentValue < prevValue) || 
        (choice === CHOICE_LOWER && currentValue >= prevValue)) { 
        return true;
    }
    return false;
}

function evaluateRound3Win(choice, currentCard, allDrawnCards) {
    if (allDrawnCards.length < 2) { // Needs at least 2 previous cards for range, current makes it 3rd for this logic
        console.error("Error: Not enough cards for Round 3 logic (needs 2 previous cards).");
        return true; // Treat as loss
    }
    // The range is defined by the first two cards of the game for this player in this implementation
    const minVal = Math.min(allDrawnCards[0], allDrawnCards[1]);
    const maxVal = Math.max(allDrawnCards[0], allDrawnCards[1]);
    console.log(`[evaluateRound3Win] minVal: ${minVal}, maxVal: ${maxVal}`);
    const currentCardVal = getCardValue(currentCard.value);

    if (choice === CHOICE_OUTSIDE) {
        return currentCardVal > minVal && currentCardVal < maxVal;
    }
    
    return currentCardVal < minVal || currentCardVal > maxVal;
}

function evaluateRound4Win(choice, card) {
    return choice !== card.suit;
}

function evaluateRound5Win(choice, card) {
    return choice !== card.value;
}

function getCardValue(value) {
  const values = {
    'A': 14,
    'K': 13,
    'Q': 12,
    'J': 11
  };
  return values[value] || parseInt(value);
}

function updateRoundInfo() {
    const roundInfo = document.getElementById('roundInfo');
    const multiplierInfo = document.getElementById('roundMultiplier');

    if (gamePhase === PHASE_GAME_OVER) {
        roundInfo.textContent = 'Game Over. Place bets and click \'New Game\' to play again.';
        const anyHistoricalBets = Object.values(players).some(p => p.historicalBet > 0);
        if (anyHistoricalBets) {
            multiplierInfo.textContent = 'You can use \'Use Last Bet\' to repeat previous bets.';
        } else {
            multiplierInfo.textContent = 'Deck will be reshuffled on New Game.';
        }
    } else if (gamePhase === PHASE_BETTING) {
        initializeDeck();
        const currentActivePlayers = getActivePlayers();
        if (currentActivePlayers.size === 0) {
            roundInfo.textContent = 'Betting Phase: Place your bets!';
            multiplierInfo.textContent = 'Then click \'New Game\' if you are ready (it will appear).'; // Or guide to New Game if that's the flow.
        } else {
            const playersNeedingChoice = Array.from(currentActivePlayers).filter(name => !players[name].currentChoice).length;
            if (playersNeedingChoice > 0) {
                roundInfo.textContent = 'Betting Phase: Make your choices!';
                multiplierInfo.textContent = `Waiting for ${playersNeedingChoice} player(s) to choose.`;
            } else {
                roundInfo.textContent = 'Ready to Play!';
                multiplierInfo.textContent = 'Click Draw Card to start the game.';
            }
        }
    } else if (gamePhase === PHASE_PLAYING) {
        switch (currentRound) {
            case 1:
                roundInfo.textContent = 'Round 1: Guess if the card is Red or Black';
                multiplierInfo.textContent = `Current Round: 1 (${roundMultipliers[1]}x multiplier if you cash out)`;
                break;
            case 2:
                roundInfo.textContent = 'Round 2: Guess if the next card is higher or lower';
                multiplierInfo.textContent = `Current Round: 2 (${roundMultipliers[2]}x multiplier if you cash out)`;
                break;
            case 3:
                roundInfo.textContent = 'Round 3: Guess if the next card is inside or outside';
                multiplierInfo.textContent = `Current Round: 3 (${roundMultipliers[3]}x multiplier if you cash out)`;
                break;
            case 4:
                roundInfo.textContent = 'Round 4: Guess the suit';
                multiplierInfo.textContent = `Current Round: 4 (${roundMultipliers[4]}x multiplier if you win this round or cash out next round)`;
                break;
            case 5:
                roundInfo.textContent = 'Round 5: Cash out (20x) OR Guess the exact card value (50x!)';
                multiplierInfo.textContent = `Guess value for ${roundMultipliers[5]}x! Cash out now for ${roundMultipliers[4]}x on your original bet.`;
                break;
        }
    }
}

function handleCashOut(playerName) {
    const player = players[playerName];

    if (gamePhase !== PHASE_PLAYING || !activePlayers.has(playerName) || player.lastBet <= 0 || (currentRound <= 1 && currentRound !== 5) ) {
        if (!(currentRound === 5 && player.lastBet > 0 && activePlayers.has(playerName))) {
            console.error(`[handleCashOut] Invalid conditions for cashing out player ${playerName}.`, {
                gamePhase,
                currentRound,
                isPlayerActive: activePlayers.has(playerName),
                playerBet: player.lastBet
            });
            return;
        }
    }

    const multiplierRound = (currentRound === 5) ? 4 : currentRound - 1;
    const multiplier = roundMultipliers[multiplierRound];

    if (multiplier === undefined) {
        console.error(`[handleCashOut] No multiplier found for previous round ${multiplierRound}.`);
        return;
    }

    const winnings = player.lastBet * multiplier;
    player.chips += winnings;
    
    console.log(`[handleCashOut] Player ${playerName} cashed out. Bet: ${player.lastBet}, Multiplier: ${multiplier}x, Winnings: ${winnings}, New Chips: ${player.chips}`);

    player.lastBet = 0;

    activePlayers.delete(playerName);
    console.log(`[handleCashOut] Player ${playerName} removed from activePlayers. Active players:`, Array.from(activePlayers));

    updatePlayerArea(); 
    updateGameButtons(); 
    savePlayers();

    if (activePlayers.size === 0 && gameInProgress) {
        console.log('[handleCashOut] All active players have cashed out or been eliminated. Ending game.');
        endGame();
    }
}

function endGame() {
    console.log('[endGame] Game Over.');
    gameInProgress = false;
    gamePhase = PHASE_GAME_OVER; // Explicitly set to gameOver
    currentRound = 1; // Reset for display consistency
    
    // Reset current choices for all players, bets remain as they were at game end.
    Object.values(players).forEach(p => {
        p.currentChoice = undefined;
    });

    updateDeckDisplay(); // Reflects deck state at end of game
    updateRoundInfo();
    updatePlayerArea(); 
    updateGameButtons(); 
    savePlayers();
}

function updateWallOfShame() {
    const wallOfShameArea = document.getElementById('wallOfShameArea');
    const wallOfShameContent = document.getElementById('wallOfShameContent');
    wallOfShameContent.innerHTML = ''; // Clear previous entries

    let hasDebt = false;
    Object.entries(players).forEach(([name, player]) => {
        if (player.debt > 0) {
            hasDebt = true;
            const debtEntry = document.createElement('p');
            debtEntry.textContent = `${name}: ${player.debt} chips in debt`;
            wallOfShameContent.appendChild(debtEntry);
        }
    });

    if (hasDebt) {
        wallOfShameArea.style.display = ''; // Show the Wall of Shame
    } else {
        wallOfShameArea.style.display = 'none'; // Hide if no one is in debt
    }
}

// Add new function to start a new game
function startNewGame() {
    console.log('[startNewGame] CLICKED');
    gamePhase = PHASE_BETTING;
    gameInProgress = false;
    initializeDeck(); // CRITICAL: Initialize a new deck
    currentRound = 1;
    drawnCards = []; // Clear drawn cards from any previous game
    updateDrawnCardsDisplay();
    updateDeckDisplay(); // Update deck display after initializing

    // Reset only choices; bets placed during 'gameOver' or newly set bets are preserved.
    Object.values(players).forEach(player => {
        player.currentChoice = undefined;
    });
    
    activePlayers = getActivePlayers(); // Recalculate active players based on current bets

    updateRoundInfo();
    updatePlayerArea();
    updateGameButtons();
    savePlayers();
}

// Add this new function to check game state
function shouldGameBeInProgress() {
    // Check if any players have bets placed
    const hasBets = Object.values(players).some(player => player.lastBet > 0);
    // Check if any players are active
    const hasActivePlayers = activePlayers.size > 0;
    // Check if we have a deck initialized
    const hasDeck = deck && deck.length > 0;
    
    return hasBets && hasActivePlayers && hasDeck;
}

function updateDeckDisplay() {
  console.log('[updateDeckDisplay] deck:', deck);
  const deckDiv = document.getElementById('deck');
    
    if (deckDiv) {
      // Update the CSS variable
      deckDiv.style.setProperty('--deck-content', `"${deck.length > 0 ? deck.length : 'Empty'}"`);    
    }
}

function toggleSelectAllPlayers(selectAllCheckbox) {
    const checkboxes = document.querySelectorAll('.player-checkbox');
    checkboxes.forEach(checkbox => {
        checkbox.checked = selectAllCheckbox.checked;
    });
}

function saveGameState() {
  const gameState = {
    players,
    deck,
    drawnCards,
    currentRound,
    gameInProgress,
    activePlayers: Array.from(activePlayers)
  };
  localStorage.setItem('gameState', JSON.stringify(gameState));
}

function loadGameState() {
  const savedState = localStorage.getItem('gameState');
  if (savedState) {
    const gameState = JSON.parse(savedState);
    players = gameState.players;
    deck = gameState.deck;
    drawnCards = gameState.drawnCards;
    currentRound = gameState.currentRound;
    gameInProgress = gameState.gameInProgress;
    activePlayers = new Set(gameState.activePlayers);
    updatePlayerArea();
    updateRoundInfo();
    updateDebugNextCardDisplay();
  }
}

// Call loadGameState on window load
window.onload = () => {
  loadGameState();
  updateRoundInfo();
  updatePlayerArea();
  updateGameButtons();
  updateDeckDisplay();
  document.getElementById('debugArea').style.display = 'block';
};

// Update savePlayers to save the entire game state
function savePlayers() {
  saveGameState();
  updateDeckDisplay();
  updateDebugNextCardDisplay();
}

// Helper: Get active players (bet > 0)
function getActivePlayers() {
    return new Set(Object.keys(players).filter(name => players[name].lastBet > 0));
}

// Helper: Check if all active players have made their choices
function allActivePlayersMadeChoices() {
    if (activePlayers.size === 0) return false;
    return Array.from(activePlayers).every(name => players[name].currentChoice !== undefined);
}

// Helper: Reset all players for a new game
function resetAllPlayers() {
    Object.keys(players).forEach(playerName => {
        players[playerName].currentChoice = undefined;
        players[playerName].lastBet = 0;
    });
}

// Helper: Update Draw Card button state and label
function updateDrawButtonState() {
    const drawButton = document.getElementById('drawCardButton');
    if (!drawButton) return;
    if (!gameInProgress) {
        if (activePlayers.size > 0 && allActivePlayersMadeChoices()) {
            drawButton.disabled = false;
            drawButton.textContent = 'Draw Card';
        } else {
            drawButton.disabled = true;
            drawButton.textContent = 'Draw Card';
        }
    } else {
        drawButton.textContent = 'Draw Card';
        drawButton.disabled = !allActivePlayersMadeChoices();
    }
}

function updateGameButtons() {
    const newGameButton = document.getElementById('newGameButton');
    const drawCardButton = document.getElementById('drawCardButton');
    if (!newGameButton || !drawCardButton) return;

    const currentActivePlayers = getActivePlayers(); // Get current players with bets
    const allChoicesMadeForBetting = Array.from(currentActivePlayers).every(name => players[name].currentChoice !== undefined && players[name].lastBet > 0);
    const allChoicesMadeForPlaying = Array.from(activePlayers).every(name => players[name].currentChoice !== undefined); // activePlayers is specific to current game

    console.log('[updateGameButtons] gamePhase:', gamePhase, 'currentActivePlayers:', Array.from(currentActivePlayers), 'allChoicesMadeForBetting:', allChoicesMadeForBetting, 'allChoicesMadeForPlaying:', allChoicesMadeForPlaying);

    if (gamePhase === PHASE_GAME_OVER) {
        newGameButton.style.display = '';
        drawCardButton.style.display = 'none';
        newGameButton.disabled = false;
        console.log('[updateGameButtons] gameOver phase: Showing New Game button.');
    } else if (gamePhase === PHASE_BETTING) {
        newGameButton.style.display = 'none';
        drawCardButton.style.display = '';
        // Enable Draw Card only if there are players with bets AND all of them have made choices for Round 1.
        drawCardButton.disabled = !(currentActivePlayers.size > 0 && allChoicesMadeForBetting);
        console.log('[updateGameButtons] Betting phase: Draw Card button visible. Enabled:', !drawCardButton.disabled);
    } else if (gamePhase === PHASE_PLAYING) {
        newGameButton.style.display = 'none';
        drawCardButton.style.display = '';
        // Enable Draw Card if all *currently in-game* active players have made their choices for the current round.
        drawCardButton.disabled = !(activePlayers.size > 0 && allChoicesMadeForPlaying);
        console.log('[updateGameButtons] Playing phase: Draw Card button visible. Enabled:', !drawCardButton.disabled);
    }
}

function updateDebugNextCardDisplay() {
    const debugNextCardDiv = document.getElementById('debugNextCard');
    const isChecked = document.getElementById('toggleDebugNextCard').checked;
    
    const theme = localStorage.getItem('theme');

    if (!isChecked) {
        debugNextCardDiv.textContent = 'Next Card: (Hidden)';
        debugNextCardDiv.style.color = theme === 'dark' ? 'white' : 'black';
        return;
    }

    if (deck && deck.length > 0) {
        const nextCard = deck[deck.length - 1]; // Peek at the last card (next to be drawn)
        debugNextCardDiv.textContent = `Next Card: ${nextCard.value}${nextCard.suit}`;
        debugNextCardDiv.style.color = [SUIT_HEARTS, SUIT_DIAMONDS].includes(nextCard.suit) ? 'red' : theme === 'dark' ? 'white' : 'black';
    } else {
        debugNextCardDiv.textContent = 'Next Card: (Deck Empty)';
        debugNextCardDiv.style.color =  theme === 'dark' ? 'white' : 'black';
    }
}

</script>
</body>
</html>
